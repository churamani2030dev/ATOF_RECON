package org.example;

import org.jlab.jnp.hipo4.data.Bank;
import org.jlab.jnp.hipo4.data.Event;
import org.jlab.jnp.hipo4.io.HipoReader;
import org.jfree.chart.ChartFactory;
import org.jfree.chart.ChartPanel;
import org.jfree.chart.JFreeChart;
import org.jfree.chart.plot.PlotOrientation;
import org.jfree.data.xy.XYSeries;
import org.jfree.data.xy.XYSeriesCollection;

import javax.swing.*;
import java.util.ArrayList;
import java.util.List;

public class ZAndPhiForBarsZPositionAndTimePlotterWithDBSCAN {

    private static final int NUM_BARS = 60;  // Number of bars
    private static final int NUM_WEDGES = 10; // Number of wedges per bar
    private static final double WEDGE_THICKNESS = 30.0; // Thickness of each wedge in mm
    private static final int NUM_LAYERS = 4;    // Number of layers (0-3)
    private static final double VELOCITY_EFF = 200.0;
    private static final double Z_THRESHOLD = 5.0;
    private static final double PHI_THRESHOLD = 0.01;
    private static final double TIME_THRESHOLD = 1.0;

    public static void main(String[] args) {
        if (args.length < 1) {
            System.err.println("Please provide the path to the HIPO file.");
            System.exit(1);
        }

        String hipoFilePath = args[0];
        HipoReader reader = new HipoReader();
        reader.open(hipoFilePath);

        if (!reader.getSchemaFactory().hasSchema("ATOF::adc")) {
            System.err.println("Schema ATOF::adc not found in the HIPO file.");
            reader.close();
            System.exit(1);
        }

        processEvents(reader);
        reader.close();
    }

    private static void processEvents(HipoReader reader) {
        Bank atofAdcBank = new Bank(reader.getSchemaFactory().getSchema("ATOF::adc"));
        Event event = new Event();

        List<Double> deltaZList = new ArrayList<>();
        List<Double> deltaPhiList = new ArrayList<>();
        List<Double> deltaTimeList = new ArrayList<>();
        List<Integer> eventIndicesForDeltas = new ArrayList<>();

        List<Integer> clusterSizes = new ArrayList<>();
        List<Integer> clusterIndices = new ArrayList<>();

        int eventIndex = 0;
        while (reader.hasNext()) {
            reader.nextEvent(event);
            event.read(atofAdcBank);

            int numRows = atofAdcBank.getRows();
            System.out.println("\nProcessing event " + eventIndex + " with " + numRows + " hits.");

            List<EventData> eventDataList = new ArrayList<>();
            for (int rowIndex = 0; rowIndex < numRows; rowIndex++) {
                int sector = atofAdcBank.getByte("sector", rowIndex);
                int layer = atofAdcBank.getByte("layer", rowIndex);
                int component = atofAdcBank.getShort("component", rowIndex);
                int order = atofAdcBank.getByte("order", rowIndex);
                int adc = atofAdcBank.getInt("ADC", rowIndex);
                double time = atofAdcBank.getFloat("time", rowIndex);

                if (layer < 0 || layer >= NUM_LAYERS) continue; // Validate layer

                double zBar = calculateZForBar(atofAdcBank, rowIndex);
                double phiBar = calculatePhiForBar(component);
                double zWedge = calculateZForWedge(rowIndex);
                double timeWedge = time;

                // Calculate deltas (bar - wedge)
                double deltaZ = zBar - zWedge;
                double deltaPhi = phiBar - calculatePhiForBar(component);
                double deltaTime = calculateBarTime(atofAdcBank, rowIndex) - timeWedge;

                deltaZList.add(deltaZ);
                deltaPhiList.add(deltaPhi);
                deltaTimeList.add(deltaTime);
                eventIndicesForDeltas.add(eventIndex);

                eventDataList.add(new EventData(zWedge, zBar, deltaPhi, timeWedge, time));
            }

            // Clustering
            List<Cluster> clusters = new ArrayList<>();
            formClusters(eventDataList, clusters);

            clusterSizes.add(clusters.size());
            clusterIndices.add(eventIndex);

            eventIndex++;
        }

        // Plot results
        plotDeltas(eventIndicesForDeltas, deltaZList, deltaPhiList, deltaTimeList);
        plotClusterSizes(clusterIndices, clusterSizes);
    }

    private static void plotDeltas(List<Integer> eventIndices, List<Double> deltaZList, List<Double> deltaPhiList, List<Double> deltaTimeList) {
        plotScatterPlot("Delta Z vs Event Index", "Event Index", "Delta Z (mm)", eventIndices, deltaZList);
        plotScatterPlot("Delta Phi vs Event Index", "Event Index", "Delta Phi (radians)", eventIndices, deltaPhiList);
        plotScatterPlot("Delta Time vs Event Index", "Event Index", "Delta Time (ns)", eventIndices, deltaTimeList);
    }

    private static void plotClusterSizes(List<Integer> eventIndices, List<Integer> clusterSizes) {
        XYSeries series = new XYSeries("Cluster Size vs Event Index");
        for (int i = 0; i < clusterSizes.size(); i++) {
            series.add(eventIndices.get(i), clusterSizes.get(i));
        }
        XYSeriesCollection dataset = new XYSeriesCollection(series);
        JFreeChart chart = ChartFactory.createScatterPlot(
                "Cluster Size vs Event Index", "Event Index", "Cluster Size", dataset, PlotOrientation.VERTICAL, true, true, false);
        displayChart(chart, "Cluster Size vs Event Index");
    }

    private static void plotScatterPlot(String title, String xAxisLabel, String yAxisLabel, List<Integer> xData, List<Double> yData) {
        XYSeries series = new XYSeries(title);
        for (int i = 0; i < xData.size(); i++) {
            series.add(xData.get(i), yData.get(i));
        }
        XYSeriesCollection dataset = new XYSeriesCollection(series);
        JFreeChart chart = ChartFactory.createScatterPlot(title, xAxisLabel, yAxisLabel, dataset, PlotOrientation.VERTICAL, true, true, false);
        displayChart(chart, title);
    }

    private static void displayChart(JFreeChart chart, String title) {
        JFrame frame = new JFrame(title);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.add(new ChartPanel(chart));
        frame.pack();
        frame.setVisible(true);
    }

    private static double calculateZForBar(Bank bank, int rowIndex) {
        double timeLeftPMT = bank.getFloat("time", rowIndex);
        double timeRightPMT = bank.getFloat("time", rowIndex + 1);
        return VELOCITY_EFF * (timeRightPMT - timeLeftPMT) / 2.0;
    }

    private static double calculateBarTime(Bank bank, int rowIndex) {
        double timeLeftPMT = bank.getFloat("time", rowIndex);
        double timeRightPMT = bank.getFloat("time", rowIndex + 1);
        return Math.min(timeLeftPMT, timeRightPMT);
    }

    private static double calculateZForWedge(int wedgeIndex) {
        return (wedgeIndex - (NUM_WEDGES - 1) / 2.0) * WEDGE_THICKNESS;
    }

    private static double calculatePhiForBar(int barIndex) {
        double phiMin = -Math.PI;
        double phiMax = Math.PI;
        return phiMin + (phiMax - phiMin) * barIndex / NUM_BARS;
    }

    private static void formClusters(List<EventData> events, List<Cluster> clusters) {
        for (EventData event : events) {
            boolean addedToCluster = false;
            for (Cluster cluster : clusters) {
                if (Math.abs(cluster.zBar - event.zWedge) < Z_THRESHOLD &&
                    Math.abs(cluster.phiBar - event.phiWedge) < PHI_THRESHOLD &&
                    Math.abs(cluster.timeBar - event.timeWedge) < TIME_THRESHOLD) {
                    cluster.addEvent(event);
                    addedToCluster = true;
                    break;
                }
            }
            if (!addedToCluster) {
                Cluster newCluster = new Cluster();
                newCluster.addEvent(event);
                clusters.add(newCluster);
            }
        }
    }

    private static class EventData {
        double zWedge, zBar, phiWedge, timeWedge, timeBar;

        EventData(double zWedge, double zBar, double phiWedge, double timeWedge, double timeBar) {
            this.zWedge = zWedge;
            this.zBar = zBar;
            this.phiWedge = phiWedge;
            this.timeWedge = timeWedge;
            this.timeBar = timeBar;
        }
    }

    private static class Cluster {
        double zBar, phiBar, timeBar;
        List<EventData> events;

        Cluster() {
            events = new ArrayList<>();
        }

        public void addEvent(EventData event) {
            events.add(event);
            if (events.size() == 1) {
                zBar = event.zBar;
                phiBar = event.phiWedge;
                timeBar = event.timeBar;
            }
        }

        public int getSize() {
            return events.size();
        }
    }
}

